# Pull Requests and Code Reviews

## Resources

- Google: [Google Engineering Practices Documentation](https://google.github.io/eng-practices/)  
- ChatGPT: [PR Policy Guidelines](https://chatgpt.com/share/68400db1-fb78-800b-91df-c24981f3150c)  
- ChatGPT: [Top 10 Code Review Principles](https://chatgpt.com/share/6840125c-6fc8-800b-a385-ec726ed972cd)  

---

## Small PRs

### Pros of Small PRs

- Faster, higher-quality reviews – ≤200 LOC is easier to review thoroughly
- Quicker feedback loops – authors get timely input while context is fresh
- Easier rollback – focused changes make reverts low-risk
- Lower merge-conflict surface – smaller diffs reduce rebase pain
- Encourages clear intent – each PR targets one concern, improving clarity and history
- AI-friendly – tooling like Copilot performs better on small, self-contained diffs
- Supports continuous delivery – small deltas integrate cleanly and keep `main` stable

### Cons of Small PRs

- Review overhead – more PRs means more CI runs and approvals
- Inter-PR dependencies – chained PRs can block each other and slow down progress
  - Addressed by `qs dev --pr` (create a dev branch from the PR branch) and merging PRs, rather than squashing
- Partial feature exposure – merging in-progress PRs may expose unstable states
  - Feature flags
  - Activate the feature by the last PR
- Potential design local-optima – slicing too narrowly may prevent broader refactor insights
  - Means poor architecting
- Feels slower at first – small PRs require more planning and splitting, which can seem like extra work

### Example of hypothetical splitting large PR

- Pull request: [#3749 APIv2 notification: implement subscribe and watch #3757](https://github.com/voedger/voedger/pull/3757)
  - LOC = +446 + |-143| = 589
- [Analysis by o3 model](https://chatgpt.com/share/6841bc88-accc-800b-b2ff-27306ee830f2)

---

## Excerpts from [Google: Small CLs](https://google.github.io/eng-practices/review/developer/small-cls.html)

- **Reject reason**: Note that reviewers have discretion to reject your change outright for the sole reason of it being too large. Usually they will thank you for your contribution but request that you somehow make it into a series of smaller changes. It can be a lot of work to split up a change after you’ve already written it, or require lots of time arguing about why the reviewer should accept your large change. It’s easier to just write small CLs in the first place
- **What is “too large”?**: There are no hard and fast rules about how large is “too large.” 100 lines is usually a reasonable size for a CL, and 1000 lines is usually too large, but it’s up to the judgment of your reviewer. The number of files that a change is spread across also affects its “size.” A 200-line change in one file might be okay, but spread across 50 files it would usually be too large
- **When large changes aren’t bad?**: There are a few situations in which large changes aren’t as bad:  
  - You can usually count deletion of an entire file as being just one line of change, because it doesn’t take the reviewer very long to review  
  - Sometimes a large CL has been generated by an automatic refactoring tool that you trust completely, and the reviewer’s job is just to verify and say that they really do want the change. These CLs can be larger, although some of the caveats from above (such as merging and testing) still apply
- **Can’t Make it Small Enough**?: Sometimes you will encounter situations where it seems like your CL has to be large. This is very rarely true. Authors who practice writing small CLs can almost always find a way to decompose functionality into a series of small changes
- **Waste a lot of time**: If you write a small CL and then you wait for your reviewer to approve it before you write your next CL, then you’re going to waste a lot of time. So you want to find some way to work that won’t block you while you’re waiting for review. This could involve having multiple projects to work on simultaneously, finding reviewers who agree to be immediately available, doing in-person reviews, pair programming, or splitting your CLs in a way that allows you to continue working immediately

